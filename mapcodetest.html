<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>MapLibreï¼šæ—¥æœ¬ã ã‘è¡¨ç¤ºï¼‹ãƒ”ãƒ³è¨­ç½®ï¼ˆé«˜ã‚ºãƒ¼ãƒ ï¼‰</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link href="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.css" rel="stylesheet" />
  <script src="https://unpkg.com/maplibre-gl@3.6.1/dist/maplibre-gl.js"></script>
  <style>
    html,body,#map { height:100%; margin:0; }
    body { background:#BFD9F2; }
    .marker{
      background-image:url('https://cdn-icons-png.flaticon.com/512/684/684908.png');
      background-size:contain; width:30px; height:30px; cursor:pointer;
    }
    /* ãƒœãƒƒã‚¯ã‚¹ã‚ºãƒ¼ãƒ ä¸­ã®è¦‹ãŸç›®ã‚’å°‘ã—ã‚ã‹ã‚Šã‚„ã™ãï¼ˆä»»æ„ï¼‰ */
    .maplibregl-ctrl-boxzoom { border:2px dashed #1e90ff; background:rgba(30,144,255,.1); }
  </style>
</head>
<body>
  <div id="map"></div>

  <script>
    const STYLE_URL = 'https://tile.openstreetmap.jp/styles/osm-bright-ja/style.json';

    // æ—¥æœ¬ã®ãƒ‘ãƒ³åˆ¶é™ï¼ˆä¸é‚£å›½å´ã«ä½™è£•ã‚’æŒãŸã›ã‚‹ï¼‰
    const jpBounds = [[121.5, 19.5], [153.5, 47.5]]; // [SW, NE] (lng,lat)

    const map = new maplibregl.Map({
      container: 'map',
      style: STYLE_URL,
      center: [138.25, 36.2],
      zoom: 5,
      maxZoom: 22,          // â† ã‚‚ã£ã¨æ‹¡å¤§ã§ãã‚‹
      maxBounds: jpBounds,  // â† æ—¥æœ¬åŸŸå¤–ã¸å‡ºãªã„
      dragRotate: false,
      pitchWithRotate: false
    });

    // ã‚ºãƒ¼ãƒ ãƒœã‚¿ãƒ³è¡¨ç¤ºï¼ˆä¸é‚£å›½ã‚’ç‹™ã„ã‚„ã™ãï¼‰
    map.addControl(new maplibregl.NavigationControl({ visualizePitch:false }), 'top-left');

    // ã‚¯ãƒªãƒƒã‚¯ã§ãƒ”ãƒ³ç®¡ç†
    const markers = [];

    // --- ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ï¼ˆé€†ãƒã‚¹ã‚¯ä½œæˆãªã©ï¼‰ ---
    function ringArea(ring){let s=0;for(let i=0,j=ring.length-1;i<ring.length;j=i++){const[x1,y1]=ring[j],[x2,y2]=ring[i];s+=(x2-x1)*(y2+y1);}return s;}
    const ensureCCW = r => ringArea(r) < 0 ? r : r.slice().reverse();
    const ensureCW  = r => ringArea(r) > 0 ? r : r.slice().reverse();

    function extractOuterRingsFromGC(gc){
      const rings=[]; (gc.geometries||[]).forEach(g=>{
        if(g.type==='Polygon'&&g.coordinates?.[0]) rings.push(g.coordinates[0]);
        if(g.type==='MultiPolygon') (g.coordinates||[]).forEach(p=>p[0]&&rings.push(p[0]));
      }); return rings;
    }

    function buildInverseMaskFC(japanRings){
      const world = ensureCCW([[-180,-90],[180,-90],[180,90],[-180,90],[-180,-90]]);
      const holes = japanRings.map(ensureCW);
      return { type:'FeatureCollection', features:[{
        type:'Feature', properties:{}, geometry:{ type:'Polygon', coordinates:[world, ...holes] }
      }]};
    }

    map.on('load', async () => {
      // 1) ã‚ãªãŸã®æ—¥æœ¬ãƒãƒªã‚´ãƒ³ï¼ˆjapan3.geojsonï¼‰ã‚’èª­ã¿è¾¼ã¿
      const res = await fetch('japan3.geojson');
      if(!res.ok){ alert('japan3.geojson ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ï¼ˆindex.html ã¨åŒã˜ãƒ•ã‚©ãƒ«ãƒ€ã«ç½®ã„ã¦ãã ã•ã„ï¼‰'); return; }
      const gc = await res.json();
      const rings = extractOuterRingsFromGC(gc);
      if(!rings.length){ alert('japan3.geojson ã«ãƒãƒªã‚´ãƒ³ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“'); return; }

      // 2) é€†ãƒã‚¹ã‚¯ï¼ˆä¸–ç•Œâˆ’æ—¥æœ¬ï¼‰ã‚’æç”»
      const maskFC = buildInverseMaskFC(rings);
      map.addSource('jp-mask', { type:'geojson', data:maskFC });
      map.addLayer({ id:'jp-mask', type:'fill', source:'jp-mask',
        paint:{ 'fill-color':'#BFD9F2', 'fill-opacity':1 }
      });

      // 3) æµ·å¤–ãƒ©ãƒ™ãƒ«ã‚’æ¶ˆã™ï¼ˆsymbol ãƒ¬ã‚¤ãƒ¤ã‚’æ—¥æœ¬å†…ã«é™å®šï¼‰
      const japanGeom = { type:'MultiPolygon', coordinates:rings.map(r=>[ensureCW(r)]) };
      (map.getStyle().layers||[])
        .filter(l=>l.type==='symbol')
        .forEach(l=>{
          const base = l.filter || true;
          map.setFilter(l.id, ['all', base, ['within', japanGeom]]);
        });

      // 4) ã‚¯ãƒªãƒƒã‚¯ã§ãƒ”ãƒ³è¨­ç½®
      map.on('click', (e) => {
        const { lng, lat } = e.lngLat;
        const el = document.createElement('div');
        el.className = 'marker';
        const marker = new maplibregl.Marker(el).setLngLat([lng, lat]).addTo(map);
        markers.push(marker);
        console.log(`ğŸ“ ${lng.toFixed(5)}, ${lat.toFixed(5)}`);
      });

      // 5) ãƒœãƒƒã‚¯ã‚¹ã‚ºãƒ¼ãƒ ã‚’æœ‰åŠ¹åŒ–ï¼ˆShift+ãƒ‰ãƒ©ãƒƒã‚°ã§å°å³¶ã‚’ç‹™ã„ã‚„ã™ãï¼‰
      map.boxZoom.enable();

      // 6) è¡¨ç¤ºç¯„å›²ã‚’æ—¥æœ¬ã¸ãƒ•ã‚£ãƒƒãƒˆ
      let minX=180,minY=90,maxX=-180,maxY=-90;
      rings.forEach(r=>r.forEach(([x,y])=>{ if(x<minX)minX=x; if(x>maxX)maxX=x; if(y<minY)minY=y; if(y>maxY)maxY=y; }));
      map.fitBounds([[minX,minY],[maxX,maxY]], { padding: 20 });
    });
  </script>
</body>
</html>
